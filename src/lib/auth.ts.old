/**
 * auth.ts
 * 
 * WHAT: Zero-trust authentication helpers for admin users.
 * WHY: Enables session-based admin access that bypasses page-level passwords.
 * 
 * Core functions:
 * - loginAdmin: validates email+password and returns session token
 * - validateAdminToken: checks if a token belongs to an active admin
 * - createAdminUser: creates new admin (super-admin only)
 * - getAllAdmins, getAdminByEmail: user management helpers
 */

import { getDb } from './db';
import type { UserDoc } from './types';
import crypto from 'crypto';

// WHAT: Collection name for admin users
const USERS_COLLECTION = 'users';

/**
 * WHAT: Generates a 32-char lowercase hex session token (MD5-style).
 * WHY: Consistent with MessMass token format; simple and URL-safe.
 */
export function generateToken(): string {
  return crypto.randomBytes(16).toString('hex');
}

/**
 * WHAT: Hashes a plaintext password to MD5-style hex (32 chars lowercase).
 * WHY: Per project convention, simple MD5 hashing for password storage.
 * NOTE: This is NOT cryptographically secure for production; suitable for MVP only.
 */
export function hashPassword(plaintext: string): string {
  return crypto.createHash('md5').update(plaintext).digest('hex');
}

/**
 * WHAT: Validates email and plaintext password, returns session token if valid.
 * WHY: Core admin login flow â€” on success, client stores token in httpOnly cookie.
 * 
 * @returns { success: true, token: string, user: UserDoc } on success
 * @returns { success: false, error: string } on failure
 */
export async function loginAdmin(
  email: string,
  password: string
): Promise<
  | { success: true; token: string; user: Omit<UserDoc, 'password'> }
  | { success: false; error: string }
> {
  const db = await getDb();
  const usersCol = db.collection<UserDoc>(USERS_COLLECTION);

  // WHAT: Find user by email
  const user = await usersCol.findOne({ email: email.toLowerCase() });
  if (!user) {
    return { success: false, error: 'Invalid email or password' };
  }

  // WHAT: Compare hashed password
  const hashedInput = hashPassword(password);
  if (user.password !== hashedInput) {
    return { success: false, error: 'Invalid email or password' };
  }

  // WHAT: Generate session token
  const token = generateToken();

  // WHAT: Store token in a sessions collection (simple approach: store token with userId and expiry)
  // WHY: Enables token validation and logout without storing in user doc directly
  const sessionsCol = db.collection('sessions');
  const now = new Date().toISOString();
  await sessionsCol.insertOne({
    token,
    userId: user._id,
    email: user.email,
    createdAt: now,
    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days
  });

  // WHAT: Return success with token and safe user data (no password)
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { password: _, ...safeUser } = user;
  return { success: true, token, user: safeUser };
}

/**
 * WHAT: Validates a session token and returns associated user if valid.
 * WHY: Middleware and API routes use this to check admin privileges.
 * 
 * @returns UserDoc (without password) if token is valid and not expired
 * @returns null if token is invalid or expired
 */
export async function validateAdminToken(
  token: string
): Promise<Omit<UserDoc, 'password'> | null> {
  if (!token || token.length !== 32) return null;

  const db = await getDb();
  const sessionsCol = db.collection('sessions');

  // WHAT: Find session by token
  const session = await sessionsCol.findOne({ token });
  if (!session) return null;

  // WHAT: Check expiration
  const now = new Date();
  if (session.expiresAt && new Date(session.expiresAt) < now) {
    // WHAT: Clean up expired session
    await sessionsCol.deleteOne({ token });
    return null;
  }

  // WHAT: Fetch user from users collection
  const usersCol = db.collection<UserDoc>(USERS_COLLECTION);
  const user = await usersCol.findOne({ _id: session.userId });
  if (!user) return null;

  // WHAT: Return user without password field
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { password: _, ...safeUser } = user;
  return safeUser;
}

/**
 * WHAT: Logs out admin by deleting session token.
 * WHY: Cleans up server-side session state.
 */
export async function logoutAdmin(token: string): Promise<boolean> {
  if (!token) return false;
  const db = await getDb();
  const result = await db.collection('sessions').deleteOne({ token });
  return result.deletedCount === 1;
}

/**
 * WHAT: Creates a new admin user (only super-admin can call this).
 * WHY: User management for zero-trust system.
 * 
 * @param requesterRole - role of the requester (must be 'super-admin')
 * @returns { success: true, userId: string } on success
 * @returns { success: false, error: string } on failure
 */
export async function createAdminUser(
  email: string,
  name: string,
  password: string,
  role: 'admin' | 'super-admin',
  requesterRole: string
): Promise<
  | { success: true; userId: string }
  | { success: false; error: string }
> {
  // WHAT: Only super-admin can create users
  if (requesterRole !== 'super-admin') {
    return { success: false, error: 'Only super-admin can create users' };
  }

  const db = await getDb();
  const usersCol = db.collection<UserDoc>(USERS_COLLECTION);

  // WHAT: Check if email already exists
  const existing = await usersCol.findOne({ email: email.toLowerCase() });
  if (existing) {
    return { success: false, error: 'Email already exists' };
  }

  // WHAT: Create user document
  const now = new Date().toISOString();
  const userDoc: UserDoc = {
    email: email.toLowerCase(),
    name,
    role,
    password: hashPassword(password),
    createdAt: now,
    updatedAt: now,
  };

  // WHAT: Insert with proper typing for MongoDB
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const result = await usersCol.insertOne(userDoc as any);
  return { success: true, userId: result.insertedId.toString() };
}

/**
 * WHAT: Fetches all admin users (without passwords).
 * WHY: Admin user management UI needs list of admins.
 */
export async function getAllAdmins(): Promise<Omit<UserDoc, 'password'>[]> {
  const db = await getDb();
  const usersCol = db.collection<UserDoc>(USERS_COLLECTION);
  const users = await usersCol.find({}).toArray();
  
  // WHAT: Strip password field from results
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  return users.map(({ password: _, ...user }) => user);
}

/**
 * WHAT: Fetches admin by email (without password).
 * WHY: Lookup helper for user management.
 */
export async function getAdminByEmail(
  email: string
): Promise<Omit<UserDoc, 'password'> | null> {
  const db = await getDb();
  const usersCol = db.collection<UserDoc>(USERS_COLLECTION);
  const user = await usersCol.findOne({ email: email.toLowerCase() });
  if (!user) return null;

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { password: _, ...safeUser } = user;
  return safeUser;
}
